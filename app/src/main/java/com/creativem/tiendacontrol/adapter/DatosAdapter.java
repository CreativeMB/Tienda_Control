package com.creativem.tiendacontrol.adapter;import android.content.Context;import android.util.Log;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.EditText;import android.widget.ImageView;import android.widget.TextView;import android.widget.Toast;import androidx.annotation.NonNull;import androidx.appcompat.app.AlertDialog;import androidx.cardview.widget.CardView;import androidx.core.content.ContextCompat;import androidx.recyclerview.widget.GridLayoutManager;import androidx.recyclerview.widget.RecyclerView;import com.creativem.tiendacontrol.R;import com.creativem.tiendacontrol.helper.PuntoMil;import com.creativem.tiendacontrol.model.Items;import com.google.firebase.database.DatabaseReference;import com.google.firebase.database.FirebaseDatabase;import java.text.DecimalFormat;import java.text.DecimalFormatSymbols;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.HashSet;import java.util.List;import java.util.Locale;public class DatosAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {    private static final int VIEW_TYPE_EMPTY = 0;    private static final int VIEW_TYPE_ITEM = 1;    private List<Items> itemsList;    private List<Items> originalItemsList; //Para mantener una copia de todos los items    private Context context;    private OnDataChangedListener onDataChangedListener;    private static final String TAG = "DatosAdapter";    // Interfaz para notificar cambios    public interface OnDataChangedListener {        void onDataChanged();    }    public DatosAdapter(Context context, ArrayList<Items> listaVentas, OnDataChangedListener listener) {        this.context = context;        this.originalItemsList = new ArrayList<>(listaVentas);        this.itemsList = new ArrayList<>(listaVentas);        this.onDataChangedListener = listener;        ordenarPorFecha();    }    @NonNull    @Override    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {        if (viewType == VIEW_TYPE_ITEM) {            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.itemdatosdatos, parent, false);            return new ContactoViewHolder(view);        } else {            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.datosinicio, parent, false);            return new EmptyViewHolder(view);        }    }    @Override    public void onBindViewHolder(@NonNull RecyclerView.ViewHolder holder, int position) {        if (holder instanceof ContactoViewHolder) {            ContactoViewHolder contactoViewHolder = (ContactoViewHolder) holder;            Items item = itemsList.get(position);            contactoViewHolder.viewProducto.setText(item.getProducto());            double valor = item.getValor();            contactoViewHolder.viewValor.setText(formatoNumerico(Math.abs(valor)));            contactoViewHolder.viewDetalles.setText(item.getDetalles());            contactoViewHolder.viewCantidad.setText(String.format("Unds: %d", item.getCantidad()));            // Formatear el timestamp            SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy hh:mm a", Locale.getDefault());            if(item.getTimestamp() != null){                String formattedDate = sdf.format(item.getTimestamp());                contactoViewHolder.viewFecha.setText(formattedDate);            } else {                contactoViewHolder.viewFecha.setText("Sin fecha"); // Manejo para fechas nulas            }            int colorFondo = valor < 0 ? R.color.colorFondoNegativo : R.color.colorFondoPositivo;            contactoViewHolder.cardView.setCardBackgroundColor(ContextCompat.getColor(context, colorFondo));            int icono = valor < 0 ? R.drawable.egreso : R.drawable.ingreso;            contactoViewHolder.imageItems.setImageResource(icono);        } else if (holder instanceof EmptyViewHolder) {            // No se necesita hacer nada aquí si no hay elementos específicos para configurar            // en la vista EmptyViewHolder.        }    }    public void filtrado(final String txtBuscar) {        itemsList.clear();        if (txtBuscar.isEmpty()) {            itemsList.addAll(originalItemsList);        } else {            String buscarMinusculas = txtBuscar.toLowerCase();            for (Items item : originalItemsList) {                if (item.getProducto().toLowerCase().contains(buscarMinusculas)) {                    itemsList.add(item);                }            }        }        ordenarPorFecha();        notifyDataSetChanged();    }    @Override    public int getItemCount() {        return itemsList.isEmpty() ? 1 : itemsList.size();    }    @Override    public int getItemViewType(int position) {        return itemsList.isEmpty() ? VIEW_TYPE_EMPTY : VIEW_TYPE_ITEM;    }    private String formatoNumerico(double valor) {        DecimalFormatSymbols symbols = new DecimalFormatSymbols();        symbols.setGroupingSeparator('.');        DecimalFormat df = new DecimalFormat("#,###", symbols);        return "$" + df.format(valor);    }    public void setItems(ArrayList<Items> items) {        this.originalItemsList.clear();        this.originalItemsList.addAll(items);        this.itemsList.clear();        this.itemsList.addAll(originalItemsList);        ordenarPorFecha();        notifyDataSetChanged();    }    private void ordenarPorFecha() {        Collections.sort(itemsList, (item1, item2) -> Long.compare(item2.getTimestamp(), item1.getTimestamp()));    }    public class ContactoViewHolder extends RecyclerView.ViewHolder {        TextView viewProducto, viewValor, viewDetalles, viewCantidad, viewFecha;        ImageView imageItems;        CardView cardView;        public ContactoViewHolder(@NonNull View itemView) {            super(itemView);            viewProducto = itemView.findViewById(R.id.viewProducto);            viewValor = itemView.findViewById(R.id.viewValor);            viewDetalles = itemView.findViewById(R.id.viewDetalles);            viewCantidad = itemView.findViewById(R.id.viewCantidad);            viewFecha = itemView.findViewById(R.id.viewFecha);            cardView = itemView.findViewById(R.id.cardView);            imageItems = itemView.findViewById(R.id.imageItems);            itemView.setOnClickListener(v -> {                int position = getAdapterPosition();                if (position != RecyclerView.NO_POSITION) {                    Items item = itemsList.get(position);                    mostrarDialogoOpciones(item, position);                }            });        }    }    private void mostrarDialogoOpciones(final Items item, final int position) {        LayoutInflater inflater = LayoutInflater.from(context);        View dialogView = inflater.inflate(R.layout.menueditareliminar, null);        TextView opcionEditar = dialogView.findViewById(R.id.opcionEditar);        TextView opcionEliminar = dialogView.findViewById(R.id.opcionEliminar);        AlertDialog dialog = new AlertDialog.Builder(context, R.style.TransparentDialogTheme)                .setView(dialogView)                .create();        opcionEditar.setOnClickListener(v -> {            mostrarDialogoEdicion(item, position);            dialog.dismiss();        });        opcionEliminar.setOnClickListener(v -> {            eliminarItem(item, position);            dialog.dismiss();        });        dialog.show();    }    private void mostrarDialogoEdicion(final Items item, final int position) {        AlertDialog.Builder builder = new AlertDialog.Builder(context);        LayoutInflater inflater = LayoutInflater.from(context);        View view = inflater.inflate(R.layout.dialogoedicion, null);        final EditText inputProducto = view.findViewById(R.id.inputProducto);        final EditText inputValor = view.findViewById(R.id.inputValor);        final EditText inputCantidad = view.findViewById(R.id.inputCantidad);        final EditText inputDetalles = view.findViewById(R.id.inputDetalles);        inputProducto.setText(item.getProducto());        // Formatear el valor para la vista y mantener el signo negativo si es necesario        long valorLong = (long) item.getValor();        String valorFormateado = PuntoMil.getFormattedNumber(valorLong);        inputValor.setText((valorLong < 0 ? "-" : "") + valorFormateado);        inputCantidad.setText(String.valueOf(item.getCantidad()));        inputDetalles.setText(item.getDetalles());        // Aplicar el formato con separadores de mil        PuntoMil.formatNumberWithThousandSeparator(inputValor);        builder.setView(view)                .setTitle("Editar Item")                .setPositiveButton("Guardar", (dialog, which) -> {                    String concepto = inputProducto.getText().toString().trim();                    String valorStr = inputValor.getText().toString().trim();                    String cantidadStr = inputCantidad.getText().toString().trim();                    String detalles = inputDetalles.getText().toString().trim();                    if (concepto.isEmpty() || valorStr.isEmpty()|| cantidadStr.isEmpty()) {                        Toast.makeText(context, "Por favor, complete todos los campos", Toast.LENGTH_SHORT).show();                        return;                    }                    double valor;                    int cantidad;                    try {                        // Eliminar cualquier carácter no numérico antes de la conversión                        // Primero eliminar los puntos de mil, luego convertir a número                        valorStr = valorStr.replaceAll("[.,]", "");                        cantidadStr = cantidadStr.replaceAll("[^\\d]", "");                        valor = Double.parseDouble(valorStr);                        cantidad = Integer.parseInt(cantidadStr);                    } catch (NumberFormatException e) {                        Toast.makeText(context, "Formato de valor inválido", Toast.LENGTH_SHORT).show();                        return;                    }                    if (item.getValor() < 0 && valor >= 0) {                        Toast.makeText(context, "El valor debe ser negativo", Toast.LENGTH_SHORT).show();                        return;                    }                    // Si el valor original era negativo, aplicar el signo negativo                    if (item.getValor() < 0 && valor > 0) {                        valor = -valor;                    }                    double total =  valor * cantidad;                    DatabaseReference itemRef = FirebaseDatabase.getInstance().getReferenceFromUrl(item.getId());                    item.setProducto(concepto);                    item.setValor(total);                    item.setDetalles(detalles);                    item.setCantidad(cantidad);                    itemRef.setValue(item).addOnCompleteListener(task ->{                        if(task.isSuccessful()) {                            Toast.makeText(context, "Item editado en firebase", Toast.LENGTH_SHORT).show();                            if(onDataChangedListener!= null){                                onDataChangedListener.onDataChanged();                            }                        } else {                            Toast.makeText(context, "Error al editar el item en Firebase", Toast.LENGTH_SHORT).show();                            Log.e(TAG, "Error al editar el item en Firebase: "+ task.getException());                        }                    });                    dialog.dismiss();                })                .setNegativeButton("Cancelar", null);        builder.show();    }    private void eliminarItem(final Items item, final int position) {        new AlertDialog.Builder(context)                .setTitle("Confirmar Eliminación")                .setMessage("¿Está seguro de eliminar este ítem?")                .setPositiveButton("Eliminar", (dialog, which) -> {                    DatabaseReference itemRef = FirebaseDatabase.getInstance().getReferenceFromUrl(item.getId());                    itemRef.removeValue().addOnCompleteListener(task -> {                        if(task.isSuccessful()) {                            Toast.makeText(context, "Item eliminado de firebase", Toast.LENGTH_SHORT).show();                            // Eliminamos el item de ambas listas                            originalItemsList.remove(item);                            itemsList.remove(item);                            notifyItemRemoved(position);                            notifyItemRangeChanged(position, itemsList.size()); //Actualizamos la lista                            if(onDataChangedListener != null){                                onDataChangedListener.onDataChanged();                            }                        } else {                            Toast.makeText(context, "Error al eliminar el item de firebase", Toast.LENGTH_SHORT).show();                            Log.e(TAG, "Error al eliminar el item en Firebase: " + task.getException());                        }                    });                })                .setNegativeButton("Cancelar", null)                .setIcon(R.drawable.eliminar)                .show();    }    // ViewHolder para la vista vacía    public static class EmptyViewHolder extends RecyclerView.ViewHolder {        public EmptyViewHolder(View itemView) {            super(itemView);        }    }    @Override    public void onAttachedToRecyclerView(@NonNull RecyclerView recyclerView) {        super.onAttachedToRecyclerView(recyclerView);        RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();        if (layoutManager instanceof GridLayoutManager) {            GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager;            gridLayoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup() {                @Override                public int getSpanSize(int position) {                    // La vista vacía (posición 0 cuando la lista está vacía) ocupa ambas columnas                    return getItemViewType(position) == VIEW_TYPE_EMPTY ? 2 : 1;                }            });        }    }}